# C Train For 18

## 大一C语言培训 (下)

+ [`数组`](#数组)
  + [`数组的由来`](#为什么要用数组)
  + [`基本数组 数组的定义和使用`](#数组的定义和使用)
    + [`定义数组`](#定义数组)
    + [`初始化数组`](#初始化数组)
    + [`通过数组下标访问数组的数值`](#通过数组下标访问数组的数值)
    + [`数组的简单应用 -- 排序`](#数组的简单应用)
  + [`多维数组`](#多维数组)
    + [`多维数组的声明`](#多维数组的声明)
    + [`比较常用的二维数组`](#二维数组)
      + [`初始化二维数组`](#初始化二维数组)
      + [`二维数组的赋值与访问`](#为二维数组赋值并访问二维数组的元素)
    + [`多维数组的使用`](#多维数组的使用)
+ [`指针`](#指针)
  + [`指针及其使用`](#指针及其使用)
    + [`初识指针`](#初识指针)
    + [`指针有什么用`](#指针有什么用)
    + [`指针运算`](#指针运算)
  + [`指向数组的指针`](#指向数组的指针)
    + [`指向一维数组的指针`](#指向一维数组的指针)
    + [`指向二维数组的指针`](#指向二维数组的指针)
  + [`指针数组`](#保存指针的数组)
  + [`数组指针`](#数组指针)
  + [`指针在函数中的应用`](#指针在函数中的应用)
  + [`二级指针`](#二级指针)
+ [`结构体`](#结构体)
  + [`初认识结构体`](#初识结构体)
  + [`结构体的使用`](#结构体的使用)
    + [`结构体与数组`](#结构体与数组)
    + [`结构体与指针`](#结构体与指针)
    + [`结构体的应用  -- 链表 `](#结构体的应用)
      + [`结构体变量指针`](#结构体变量指针)
      + [`数组与链表`](#数组与链表)
      + [`链表概述`](#链表概述)
      + [`链表操作`](#链表操作)
+ [`字符串`](#字符串)
  + [`初识字符串`](#初识字符串)
  + [`字符串的输入与输出`](#字符串的输入与输出)
  + [`指向字符串的指针`](#指向字符串的指针)
  + [`常见的字符串操作`](#常见的字符串操作)
    + [`赋值`](#赋值)
    + [`加法`](#加法)
    + [`修改`](#修改)
    + [`比较`](#比较)
+ [`文件`](#文件)
  + [`为什么要有文件操作`](#为什么要有文件操作)
  + [`文件的打开和关闭`](#文件的打开和关闭)
  + [`文件的读写操作`](#文件的读写操作)
    + [`写入数据`](#写入数据)
    + [`读取数据`](#读取数据)

---

## 数组

### 为什么要用数组

#### 一个典型的问题

+ 一次性获取用用户输入的十个整数，然后对每一个数据做平方处理然后输出，一般情况下，既然要一次获取10个整数,那么就必须定义十个变量来储存这是个数据，代码看起来已经非常的麻烦了，如果数量更大的话，就会更麻烦了，比如以下代码

```c
int main()
{
    int i1,i2,i3,i4 ... i10;
    scanf("%d%d%d ... %d",&i1,&i2,&i3 ... &i10);
    i1 *= i1;
    i2 *= i2;

    .....

    printf("%d%d%d.....%d",i1,i2,i3....i10);
}
```

+ 为了对这种大量数据进行处理，C语言引进了数组

### 数组的定义和使用

#### 定义数组

+ 在 C 中要声明一个数组，需要指定元素的类型和元素的数量，使用数组前，需要先定义数组，定义数组的格式如下：

```c
数据类型 数组名 [整形常量表达式], ...
type arrayName [ arraySize ];
```

+ 数组由数据类型相同的一系列元素组成，需要使用该数组时，通过声明数组告诉编译器数组中含有多少元素和这些元素的类型，编译器根据这些信息正确的创建数组 ，例如：

```c
int main()
{
    float candy[365] /*内含有365个float类型元素的数组 */
    char code[20];  /*内含有20个char类型元素的数组 */
    int book[50];   /*内含有50个int类型元素的数组 */
}
```

#### 初始化数组

+ 数组的声明并不是声明一个个单独的变量，比如 number0、number1、...、number99，而是声明一个数组变量，比如 numbers
+ 如下代码所示，用以逗号分割的数值列表 (用花括号括起来) 来初始化数组

```c
int main()
{
    int numbers[8] = {1,2,4,5,7,9,12,435};
}
```

+ 大括号 { } 之间的值的数目不能大于我们在数组声明时在方括号 [ ] 中指定的元素数目。如果你省略掉了数组的大小，数组的大小则为初始化时元素的个数。因此，如果执行以下的代码 将创建一个数组，它与前一个实例中所创建的数组是完全相同的。

```c
double balance[] = {1000.0, 2.0, 3.4, 7.0, 50.0};
```

创建完的数组balance在内存中的结构：

<div align="center">

![array_presentation.jpg](https://upload-images.jianshu.io/upload_images/9140378-1c77919410172241.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

+ 或者利用数组的下标进行赋值

```c
//下面是一个为数组中某个元素赋值的实例：

numbers[4] = 50.0;

//下面是为数组的所有元素进行赋值

int main()
{
    int num[5];
    for(int i = 0;i < 4;i ++)
        num[i] = i + 1;
}
```

创建完的数组的结构：

<div align="center">

![train4.png](https://upload-images.jianshu.io/upload_images/9140378-67efb5f61143edf0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)

</div>

#### 通过数组下标访问数组的数值

+ 如下图所示，使用 numbers[0]、numbers[1]、...、numbers[99] 来代表一个个单独的变量。数组中的特定元素可以通过索引访问。所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。，数组的首位置的下标一定是0,下标的最大值一定是数组的长度 - 1

<div align="center">

![train5.jpg](https://upload-images.jianshu.io/upload_images/9140378-a6be205a10460f5b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

+ 数组边界

在访问数组元素时，要防止数组下标超出边界，也就是说，必须确保下标时有效的值，加入有下面的声明：

```c
int bao[20];
```

那么在访问该数组时，要确保程序中使用的数组下标在 0 ~ 19 的范围内，因为编译器不会检查出这种错误，也就是说，编译运行照常通过，但看起来运行的结果很奇怪
假设我们访问数组下标以外的数值，例如：

```c
#include "stdio.h"
int main()
{
    int lihao[3] = {1,2,3};
    for(int i =0;i < 7;i ++)
        printf("%d\n",lihao[i]);
    return 0;
}
/*
1
2
3
3
11692832
0
4199400
*/
```

+ C是相信程序员能正确的编写程序，这样C可以运行的更快，所以访问数组时C是不检查边界的，但不是所有程序员可以做到这一点，所以才出现了这个数组下标越界的问题，所以建议大家在声明数组的时候使用符号常量来表达数组的大小

```c
#define SIZE 4;
int main()
{
    int arr[SIZE];
    for(int i = 0;i < SIZE;i ++)

    ...

    return 0;
}
```

#### 数组的简单应用

两个经典的排序

+ 冒泡排序

<div align="center">

![train7.png](https://upload-images.jianshu.io/upload_images/9140378-9c4d6b09c292dac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/350)

</div>

+ 比较相邻的元素。如果第一个比第二个大，就交换他们两个，就像把大的像泡泡一样“冒”到数组后面去
+ 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
+ 针对所有的元素重复以上的步骤，除了最后一个。
+ 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

```c
int main()
{
    int i = 0,j = 0;
    int a[10] = {3,1,4,1,5,9,2,6,5,4};
    for(i = 0;i < 9;i ++)
    {
        int temp = 0;
        for(j = 0;j < 9 - i;j ++)
        {
            if(a[j] > a[j + 1])
            {
                //将位置 j + 1 的数与位置j的数进行交换
                temp = a[j + 1];
                a[j + 1] = a[j];
                a[j] = temp;
            }
        }
    }
    for (i = 0;i < 10;i ++)
        printf("%d ",a[i]);
    return 0;  
}

/*
1 1 2 3 4 4 5 5 6 9
*/
```

[动态演示 -- 冒泡排序算法可视化](https://visualgo.net/zh/sorting)

+ 选择排序

<div align="center">

![train8.png](https://upload-images.jianshu.io/upload_images/9140378-0c2f621c106a60ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/380)

</div>

+ 选择排序（从小到大）的基本思想是，首先，选出最小的数，放在第一个位置；然后，选出第二小的数，放在第二个位置；以此类推，直到所有的数从小到大排序。
+ 在实现上，我们通常是先确定第i小的数所在的位置，然后，将其与第i个数进行交换

```c
#include "stdio.h"
int main()
{
    int i = 0,j = 0;
    int temp = 0;
    int a[10] = {3,1,4,1,5,9,2,6,5,4};
    for(i = 0;i < 9;i ++)
    {
        int pos = 0;
        for(j = 1;j < 10 - i;j ++)
            if(a[pos] < a[j])
                pos = j;
        if(pos != 9 - i)
        {
            temp = a[9 - i];
            a[9 - i] = a[pos];
            a[pos] = temp;
        }
    }
    for (i = 0;i < 10;i ++)
        printf("%d ",a[i]);
    return 0;  
}
/*
1 1 2 3 4 4 5 5 6 9
*/
```

[动态演示 -- 选择排序算法可视化](https://visualgo.net/zh/sorting)

### 多维数组

#### 多维数组的声明

C 语言支持多维数组。多维数组声明的一般形式如下：

```c
type name[size1][size2]...[sizeN];
```

例如，下面的声明创建了一个三维 5 . 10 . 4 整型数组：

```c
int threedim[5][10][4];
```

### 二维数组

#### 初始化二维数组

+ 初始化可以使用一个 { } 里面包含有多个数据的方式，多个数据使用逗号进行分隔,例如：

```c
数据类型 数组名[整型常量][整形常量] = { {数据1,...} , {数据2,...}, {数据3,...}, ...};

int a[3][4] = {
    {0, 1, 2, 3}, /*  初始化索引号为 0 的行 */
    {4, 5, 6, 7},  /*  初始化索引号为 1 的行 */
    {8, 9, 10, 11}  /*  初始化索引号为 2 的行 */
};
```

+ 数组的第一个下标可以直接由 “{ }” 里面的包含的 “{ }” 个数决定，所以完全可以省略第一个下标：

```c
int a[][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
```

+ 虽然二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”,以下面的二维数组 a 为例：

```c
int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
```

+ 但在内存中，a 的分布是一维线性的，整个数组占用一块连续的内存：

<div align="center">

![train3.jpg](https://upload-images.jianshu.io/upload_images/9140378-753dc9d279810b55.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

+ C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。

<div align="center">

![train11.jpg](https://upload-images.jianshu.io/upload_images/9140378-7445afc38122c969.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

+ 数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。
+ C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a[0][0]、a[0][1]、a[0][2]、a[0][3]

+ 假设数组 a 中第 0 个元素的地址为 1000，那么每个一维数组的首地址如下图所示：

<div align="center">

![train9.png](https://upload-images.jianshu.io/upload_images/9140378-f382b296f8bf9418.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

#### 为二维数组赋值并访问二维数组的元素

+ 二维数组中的元素也是通过使用下标（即数组的行索引和列索引）来访问的。例如：

```c
int val = a[2][3];
```

+ 上面的语句将获取数组中第 3 行第 4 个元素。您可以通过上面的示意图来进行验证。让我们来看看下面的程序，我们将使用嵌套循环来处理二维数组：

首先定义一个二维数组

```c
/* 一个带有 3 行 4 列的数组 */
int a[3][4];
```

二维数组的赋值

+ 使用循环的嵌套来从键盘录入数据

```c
int i, j;
for(i = 0;i < 3;i ++ )
{
    for(j = 0;j < 4;j ++)
    {
        scanf("%d",&a[i][j]);
    }
}
```

<div align="center">

![train12.jpg](https://upload-images.jianshu.io/upload_images/9140378-a9894652810c62b5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

二维数组的输出

+ 同样我们使用循环的嵌套来从输出数据

```c
//输出具体数值
for ( i = 0; i < 3; i++ )
{
    for ( j = 0; j < 4; j++ )
        printf("%d ",a[i][j]);
    printf("\n");
}
/*
1 2 3 4
3 4 5 6
5 6 7 8
*/
    for ( j = 0; j < 4; j++ )
        printf("a[%d][%d] = %d\n", i,j, a[i][j]);
/*
a[0][0] = 1
a[0][1] = 2
a[0][2] = 3
a[0][3] = 4

a[1][0] = 3
a[1][1] = 4
a[1][2] = 5
a[1][3] = 6

a[2][0] = 5
a[2][1] = 6
a[2][2] = 7
a[2][3] = 8
    */
}
```

#### 多维数组的使用

从前面的学习中，大家应该都知道了，数组的维数与定数组时，数组的整型常量表达式，即下标的个数有关

+ 含有一个下标的是一维数组，包含两个下标的二维数组，很容易就可以推测出多维数组是如何定义并初始化的，如定义一个 int 型的三维数组

```c
int num[2][4][2];
```

+ 上面所定义的三维数组的储存单元数应该是：2 * 4 * 2，即16 个储存单元，无论是有几个下标的多维数组，都可以看成是数组不断嵌套的结果,而且多维数组在程序的编写中不经常用到
+ 接下来通过一个实例来让大家熟悉一下多维数组

```c
int mian()
{
    int address[3][6][4];
    for(int i = 0;i < 3;i ++)
    {
        printf("第%d栋楼\n\n"，i);
        for(int j = 0;j < 6;j ++)
        {
            printf("第%d层楼"，6 - j);
            for(int k = 0;k < 4;k ++)
            {
                address[i][j][k] = k + 1;
                printf("%d",address[i][j][k]);
            }
        }
    }
}
```

## 指针

### 指针及其使用

#### 初识指针

指针是什么？

首先理解 " & " 和 " * " ( 取地址和指针运算符 )

```c
int  var1;
char var2[10];
//打印出地址
printf("var1 变量的地址： %p\n", &var1  );
printf("var2 变量的地址： %p\n", &var2  );
/*
var1 变量的地址： 0x7fff5cc109d4
var2 变量的地址： 0x7fff5cc109de
*/
```

```c
scanf("%d",&i);//传入一个地址
//scanf的函数原型
int scanf(const char * restrict format,...);
```

如何定义指针变量？

+ 指针本身是一个变量，它存储的是数据在内存中的地址而不是数据本身的值。它的定义如下:

```c
数据类型* 变量名  或  数据类型 *变量名 //只是*的位置不同而已

int *pointer;
char *name;
```

+ 这样就定义好了两个指针变量，int 和 char 表示该这两个指针变量指向的数据类型，*表示这是指针变量。

+ 指针变量的初始化：每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址,

![train13.png](https://upload-images.jianshu.io/upload_images/9140378-ccd065db4a4c4091.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)

```c
 int a = 10,*p;  
 p = &a
 int a = 10;
 int *p = &a;
```

+ 首先我们可以理解 int * 这个是要定义一个指针p，然后因为这个指针存储的是地址所以要对a取地址(&)将值赋给指针p，也就是说这个指针p指向a。
+ 可能会对对这两种定义方法感到迷惑，其实他俩的意思是一样的。第一种定义方法定义了int型的变量 a 和 指针 p ，然后将 a 的地址赋给 p
+ 第二种是在定义指针p的同时将 a 的地址赋给指针 p。我们姑且理解为" int * "是定义指针的标志。

在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。NULL 指针是一个定义在标准库中的值为零的常量

```c
int  *ptr = NULL;
printf("ptr 的地址是 %p\n", ptr  );
return 0;
/*
结果：
ptr 的地址是 0x0
*/
```

#### 指针有什么用

这样我们就可以通过*p来找到指针所指向的变量a的地址，然后对地址中的值(值是10)进行操作。

```c
printf("%p",p)   //结果是一个地址(p指向的变量a的地址)。
printf("%d",*p)  //结果是10，变量a的值。
printf("%d",&p)  //结果是一个地址(指针p的地址，因为指针也是一个变量自己也有地址的)
```

题目：

使用指针交换两个整数变量的值，并写成函数形式，即实现void swap(int *a, int *b)函数

#### 指针运算

指针就是地址，地址在内存中也是以数的形式存在，所以指针也能做加法，减法，比较等运算

```c
int a = 5;
int *i = &a;
printf("%p\n",i);
i ++;
printf("%p\n",i);
i -= 2;
printf("%p\n",i);
return 0;
/*
000000000062FE44
000000000062FE48
000000000062FE40
*/
```

### 指向数组的指针

#### 指向一维数组的指针

为指针赋数组数据的地址

+ 数组的每个数据都保存在一个储存单元里面，只要是储存单元就会有地址，既然指针变量的储存单元可以保存地址，那么就可以用指针保存数组储存单元的地址

```c
int *p_i = NULL;   //定义指针变量
int num[5] = {1，2，3，4，5};
for(int i = 0;i < 5;i ++)
{
    p_i = &num[i];  //先让指针指向想要输出的数据
    printf("%d ",*p_i); //通过指针输出数组数据
}
```

使用数组名为指针赋值

+ 对于下面的数组和指针

```c
int num[5] = {1,2,3,4,5};
int *p_i;
```

+ 为指针赋予第一个数组数据的地址的方式为：

```c
p_i = &num[0];
```

+ 其实还可以写成下面的形式,直接将数组名赋予指针，指针需要储存的数据就是地址，而 num 就代表的是数组的首地址

```c
p_i = num;
```

指向数组的指针的加减运算,  -- 数组的另外一种遍历方式

![train14.png](https://upload-images.jianshu.io/upload_images/9140378-29428f6b9449104d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

+ 对于*(num + i), num 是数组的首地址，指向数组的首元素，而num + i 则便是数组的第 i 个元素的地址，再加上指针运算符* 就得到了该元素的值
+ array每次加一的时候，它自己的值都会增加sizeof(int)，加 i 的时候就增加i *sizeof ( int )

```c
int num[5] = {2,4,6,8,10};
for(int i = 0;i < 5;i ++)
{
    //通过数组下标遍历数组
    printf("%d",num[i]);
    //通过指针变量遍历数组
    printf("%d",*(num + i));
}
```

#### 指向二维数组的指针

跟一位数组同样的道理

```c
int num[3][2] = {{1,2},{3,4},{5,6}};
int *p_i = &num[0][0];
```

+ 不过在这里要注意的是，不能为指针直接赋予二维数组的数组名，即上面的代码不能写成: int *p_i = num;

<div align="center">

![train9.png](https://upload-images.jianshu.io/upload_images/9140378-261b27c28b07feab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

+ 假设定义一个二维数组：num[m][n];一个指针p指向了这个二维数组的首地址，那么对于数组的数据 num[i][j](0 <= i < m,0 <= j < n) ，指针变量p要想指向这个数据,那么指针变量 p = p + n * i + j;

```c
double arr[4][3] = {
    {78.4,72.1,41.2},
    {56.4,12.4,45.1},
    {12.5,14.6,20.4},
    {23.5,34.6,67.8}
}
double *p_d = &arr[0][0]; //指针变量的类型必须要跟数组类型一致
printf("二维数组中arr[3][2]位置上的数据为：%6.11f\n",*(p_d + 3 * 3 + 2));
```

### 保存指针的数组

<div align="center">

![train15.png](https://upload-images.jianshu.io/upload_images/9140378-f25fae78ce0cba15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

</div>

从名字的定义上来看，数组元素全为指针的数组就称为指针数组。

+ 一维指针数组的定义形式为： 类型名 *数组标识符[数组长度]
例如，一个一维指针数组的定义：

```c
int *ptr_array[10]
```

+ 因为[]比*的优先级高，所以也可以看成是*(ptr_array[10])，括号里面ptr_array[10]表示的是一个长度为10的数组，然后括号外面的* 说明数组的元素类型是 int* 的指针类型

+ 看一个指针数组的例子

```c
int main()
{
  int a = 16, b = 932, c = 100;
  //定义一个指针数组
  int *arr[3] = {&a, &b, &c};
  printf("%d %d %d\n", *arr[0], *arr[1], *arr[2]);
  return 0;
}
/*
16 932 100
*/

```

因为数组arr里面的元素都是指针，所以在声明指针数组的时候，把a,b,c的地址&啊，&b,&c传进去了，在输出的时候先通过 数组下标得到数组内的指针，即a,b,c的地址，然后，再通过 运算符 * 将数据取出

### 数组指针

定义方式：

```
datatype (*p)[length];
```

### 指针在函数中的应用

### 二级指针


## 结构体

### 初识结构体

为什么要有结构体？

在程序中，经常会遇到特定类型的实物需要使用过很多不同类型的数据来表述，如果全部都用单独的变量来指代每一个数据，就要定义很多非常繁琐的变量

```c
#include "stdio.h"
int main()
{
    char name[20] = "baoqianyue";
    int height = 175;
    int weight = 70;
    char sex = 'm';
    short age = 19;
    long  wealth  = 300000;
    printf("鲍骞月的个人信息：\n");
    printf("姓名：%s,身高：%d,性别：%c,年龄：%d,财产：%d\n",name,height,sex,age,wealth);
    return 0;
}
```

数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项,而结构体的出现就很好的解决了这个问题

+ 结构体的构造

```c
struct 结构类型名
{
    数据类型1 成员变量1;
    数据类型2 成员变量2;
    数据类型3 成员变量3;
    ....
}; //<- 需要注意的地方
```

+ 定义结构体变量

```c
struct Stu{
    int height;//身高
    int weight;//体重
    char sex;//性别
    int age; //年龄
    long wealth;
};
```

这个结构体名是Stut，它内部有五个成员，分别为身高，体重，性别，年龄。定义形式与普通变量定义的方式一样，只不过不能立即初始化。

+ 结构体变量的初始化

结构体也是一种数据类型，在某种意义上与int，char这些基本数据类型是同级的，所以定义变量的方式是一样的。

```c
struct student stu1,stu2;
```

对于结构体，初始化并赋值的一般形式为

```c
strcut 结构类型名 结构变量 = {数据1，数据2,...};
```

+ 结构体成员的读取和赋值

结构体成员的获取形式为：

```c
结构体变量名.成员名;
```

为单个结构体变量赋值,定义结构体变量并赋值，在这里我们定义了一个名stu1的结构体变量，并且为这个结构体

```c
    Stu stu1;
    stu1.age = 19;
    stu1.height = 175;
    stu1.sex = 'm';
    stu1.wealth = 30000;
    stu1.weight = 70;
    printf("身高：%d,性别：%c,年龄：%d,财产：%d\n",stu1.height,stu1.sex,stu1.age,stu1.wealth);
```

+ 使用typedef简化变量名

```c
typedef StudentInfo Stu;
typedef int integer;
```

### 结构体的使用
  
#### 结构体与数组
  
+ 数组作为结构体的变量

举个例子：一家店雇佣了三个兼职人员，只需要他们在一个星期内来4天就可以，此时如何定义结构体？

```c
struct schedule{
    char name;
    char sex;
    int week1;
    int week2;
    int week3;
    int week4;
};
```

使用数组节省没必要的变量

```c
struct schedule{
    char name;
    char sex;
    int week[4];
};
//简化结构体的名字
typedef schedule S;
```

```c
int main()
{
    S sd1 = {'A','m',1,2,4,6};
    S sd2 = {'A','m',3,5,6,7};
    S sd3 = {'A','m',2,3,5,7};
    printf("姓名：%c,性别：%c,工作日：%d %d %d %d",
        sd1.name,sd1.sex,sd1.week[0],sd1.week[1],sd1.week[2],sd1.week[3]);
    return 0;
}
```

+ 保存结构的数组

```c
int main()
{
    S st[3] = { {'A','m',1,2,4,6 } , {'A','m',3,5,6,7} , {'A','m',2,3,5,7} };
    for(int i = 0;i < 3;i ++)
    printf("姓名：%c,性别：%c,工作日：%d %d %d %d\n",
        st[i].name,st[i].sex,st[i].week[i],st[i].week[1],st[i].week[2],st[i].week[3]);
    return 0;
}
```

#### 结构体与指针
  
+ 结构体与函数

结构体作为函数参数，传入函数进行赋值，并将赋值完的结构体返回给主函数
传参方式与其他类型的变量或指针类似

```c
#include "stdio.h"
struct complex_num{
    int real;
    int image;
};
typedef complex_num comp;

comp assign(comp num)
{
    puts("输入复数的实部：");
    scanf("%d",&(num.real));
    puts("输入复数的实部：");
    scanf("%d",&(num.image));
    return num;
}

int main()
{
    comp com1;
    com1 = assign(com1);
    printf("%d + %di",com1.real,com1.image);
    return 0;
}
```

### 结构体的应用

结构体的应用 -- 链表

#### 结构体变量指针

![train.png](https://upload-images.jianshu.io/upload_images/9140378-105df5dddce29c6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/640)

+ 结构体变量成员指向自身

即将定义的结构体变量的地址赋予给所定义的结构体，这样定义的该结构体的指针域就只想了结构体本身

```c
struct table{
    int i;
    char c;
    struct table *st;
};
int main()
{
    table st1 = {1,'a'};
    st1.st = &st1;
    //使用结构体变量输出自身的2个成员的值
    printf("%d %c\n",st1.i,st1.c);
    //使用结构体指针域所指向的结构体输出数值
    printf("%d %c\n",st1.st->i,st1.st->c);
    return 0;
}
/*
1 a
1 a
*/
```

+ 结构体变量成员指向其他结构变量

即将定义的两个结构体变量，比方说定义了 st1 和 st2两个结构体变量，只需要将st2 的地址 赋给 st1 的指针域，这样 st1 的指针就指向了 st2

![train1.png](https://upload-images.jianshu.io/upload_images/9140378-b8b80be836c3d74a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/440)

```c
int main()
{
    table st1 = {1,'a'};
    table st2 = {2,'b'};
    st1.st = &st2;

    //使用结构体变量输出st1自身的2个成员的值
    printf("%d %c\n",st1.i,st1.c);

    //使用结构体指针域所指向的结构体输出数值,即 st2 中的数值
    printf("%d %c\n",st1.st->i,st1.st->c);

    //使用结构体变量输出st2自身的2个成员的值
    printf("%d %c\n",st2.i,st2.c);

    return 0;
}
/*
1 a
2 b
2 b
*/
```

#### 数组与链表

数组是由同类型的多个数据组成的，链表是由是由多个相同结构连接而成
但是数组中就可以存放结构体，为啥还要单独专门独立出来一个链表呢？这是因为数组的长度总是固定的，没办法动态的储存数据

```c
#include "stdio.h"
struct table{
    int i;
    char c;
    struct table *st;
};
int main()
{
    table tal[3] = {
        {1,'a'},
        {2,'b'},
        {3,'c'}
    };
    return 0;
}
```

上面的代码也能做到和链表一样的效果，甚至比链表还要简洁，但是如果程序中的结构数目是用户自己决定的话，或者说结构体的数目是位未知的，那怎么办?数组的长度可以在程序运行时不能被更改，所以说，数组跟结构体搭配的前提时数组的长度固定并且已知

#### 链表概述

![timg.jpg](https://upload-images.jianshu.io/upload_images/9140378-c16769111551b03e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/840)

1. 链表的最小单元 -- 结点

2. 链表的组成部分

一个连边通常由3部分组成：投机欸但、数据结点和尾结点

+ 头节点：

+ 数据结点：

+ 尾结点：

#### 链表操作

+ 插入结点到链表
+ 删除链表中的结点

## 字符串

### 初识字符串

什么是字符串？

### 字符串的输入与输出

### 指向字符串的指针

### 常见的字符串操作

#### 赋值

#### 加法

#### 修改

#### 比较

## 文件

### 为什么要有文件操作

### 文件的打开和关闭

### 文件的读写操作

#### 写入数据

#### 读取数据

