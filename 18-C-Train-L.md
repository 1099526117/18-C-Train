> 本次培训采用C99标准
# Hello World
- ####  你好，世界！
``` C
#include<stdio.h>  // 包含另一个文件

/* 这是一个简单的演示程序 */
int main()   // 函数名
{ // 函数体开始
	int num; // 声明
	num = 1; // 赋值表达式语句
	printf("Hello World\n"); // 调用函数
	return 0; // return 语句
} // 结束
```
- #### 程序细节
  - `#include`：这行代码是C语言预编译指令
  - `int main()函数`：C语言程序一定是从`main()`函数开始执行，并且一个项目只能有一个`main`函数。
      - `void main()`：注意，一些编译器允许这样写，但是所有的标准都未认可这种写法。而`int main()`是标准写法，使用标准写法，在将程序从一个编译器切换到另一个编译器时一般不会出现什么问题。
  - `/* ... */`：这是C语言中的注释，它允许同时注释多行。对于单行注释也可使用`//`。
  - `{ ... }`：这是花括号，一般而言，所有C函数都要使用花括号标记函数体的开始和结束。
  - `int num`：这是声明，声明一个变量一般形式是`关键字 标识符`，例如`char str`。
  - `num = 1`：赋值表达式语句。
  - `printf()`：这是C语言的一个标准输出函数。括号中的`Hello World\n`是这个函数的`实际参数`。
  - `return 0`：C语言标准中，要求main()函数返回0。但如果省略不写这一句呢？程序在运行至最外面的右花括号时会返回0。因此，可以省略main()函数的`return`语句，但是不要在其他有返回值的函数中漏掉它。强烈建议读者养成在main()函数中保留`return`语句的好习惯。

- #### 代码编写规范
  - 标识符命名规范：标识符只能由字母、数字和下划线组成，并且第一个字符必须是字母或下划线
  - 变量名应该有具体含义
  - 每条语句占一行
  - 对齐缩进4个空格字符
  - ...


# 数据类型
- #### C数据类型
![type](https://github.com/android-nuc/17-C-Train/raw/master/image/c_language.png)

- #### 什么是位、字节和字
> 位、字节和字是描述计算机数据单元或存储单元的术语。
> 最小的存储单元是位(bit)，可以储存0或1.虽然1位储存的信息有限，但是计算机中位的数量十分庞大。位是计算机内存的基本构建块。
> 字节(byte)是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。这是字节的标准定义，至少在衡量存储单位时是这样。既然1位可以表示0或1，那么8位字节就有256（2的8次方）种可能的0、1组合。通过二进制编码（仅用0和1便可表示数字），便可表示0~255的整数或一组字符。
> 字(word)是设计计算机时给定的自然存储单位，对于8位的微型计算机（如，最初的苹果机），1个字长只有8位。从那以后，个人计算机字长增至16位、32位，直到目前的64位，计算机的字长越大，其数据转移越快，允许的内存访问也快的多。
> ————《C Primer Plus》

`注意：C语言把1字节定义为char类型占用的位(bit)数。通常，char类型被定义为8位的存储单元。`

- #### 整数类型
  
|类型|存储大小|值范围|
|-|-|-|
|char|1 byte|-128 到 127 或 0 到 255|
|unsigned char|1 byte|0 到 255|
|signed char|1 byte|-128 到 127|
|int|2 或 4 bytes|-32,768 到 32,767 或 -2,147,483,648 到 2,147,483,647|
|unsigned int|2 或 4 bytes|0 到 65,535 或 0 到 4,294,967,295|
|short|2 bytes|-32,768 到 32,767|
|unsigned short|2 bytes|0 到 65,535|
|long|4 bytes|-2,147,483,648 到 2,147,483,647|
|unsigned long|4 bytes|0 到 4,294,967,295|

不同平台上数据类型的取值范围有所差异，为了得到某个类型或某个变量在特定平台上的准确大小，可以使用`sizeof`运算符，得到对象或类型的存储字节大小。

``` C
#include<stdio.h>

int main()
{
	printf("Storage size for int : %d \n", sizeof(int));
	return 0;
}
```
输出：
```
Storage size for int : 4
```
按照1个字节8位计算，那4个字节能够存储$2^{4*8}$，即$2^{32} = 4294967296$，正负数各分一半，也就是-2,147,483,648 到 2,147,483,647。



- #### 浮点类型

类型|存储大小|值范围|精度
|-|-|-|-|
float|4 byte|1.2E-38 到 3.4E+38|6 位小数
double|8 byte|2.3E-308 到 1.7E+308|15 位小数
long double|10 byte|3.4E-4932 到 1.1E+4932|19 位小数

- #### 基本数据类型所占字节数与三个方面因素有关
  - CPU位宽（即你的CPU是多少为的）
  - 操作系统位宽（笼统说就是操作系统位数，操作系统位宽取决于CPU位宽）
  - 编译器类型和版本

- #### 整型溢出
[关于原码、反码和补码更多介绍](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)

- EX.1
计算机中的计算只有二进制加法。因此，计算机在计算时实际上是取它们的补码进行加法运算。
``` C
unsigned int a;
int b = -1;
a = b;
printf("a=%u",a);
```
输出：
```
a=4294967295
```
让我们来分析一下，
首先int型的-1，对应二进制
取原码：`1000000000000000000000000000001`
取反码：`1111111111111111111111111111110`
取补码：`1111111111111111111111111111111`
而`unsigned int`型最大值对应的补码也是它，因此在赋值给`a`后，就得到了它的最大值。

- EX.2
如果整数超出了相应类型的取值范围会怎样？
``` C
#include<stdio.h>

int main()
{
	int i = 2147483647;
	unsigned int j = 4294967295;
	printf("%d %d %d\n", i, i+1, i+2);
	printf("%u %u %u\n", j, j+1, j+2);

	return 0;
}
```
输出：
```
2147483647 -2147483648 -2147483647
4294967295 0 1
```
从输出结果不难发现，当达到它们能表示的最大值时，会重新从起点开始。只不过`unsigned int`最小值为0，而`int`型最小值为-2147483648。


# 字符串和格式化输入/输出

# 运算符

# 循环语句

# 分支语句

